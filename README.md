# iOS run之前都发生了啥

简单来说，点击Run之后App进行编译、汇编、链接、代码签名以及启动执行等操作

## 编译
编译主要依靠编译器来完成。编译主要操作是预处理、代码分析、语义分析、生成中间代码、目标代码。
OSX现在使用的编译器是LLVM，最初的时候是使用的GCC做为官方编译器，但是GCC有众多限制，apple改为使用LLVM。
### 编译过程
- 预编译
 处理源文件中以#开头的预编译命令，比如#import，#define等
- 词法分析
 会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。
- 语法分析
 将上一步符号化的字符串，转化抽象为可以被计算机存储的树形结构。即抽象语法树（AST），并验证语法的正确性，例如忘记带分号。
- 语义分析
 完成语法层面的分析，主要做类型检查、符号表管理，例如给一个浮点数赋值指针类型。
- 生成中间代码
  编译器前端负责产生机器无关的中间代码，编译器后端对中间代码进行优化并转化为目标机器代码。
- 目标代码的生成与优化
  编译器后端主要包括代码生成器、代码优化器。代码生成器将中间代码转化成目标代码；代码优化器主要主要进行一些优化，比如删除多余指令，选择合适寻址方式等。
  
## 汇编
目标代码需要经过汇编器处理，才能变成机器上可以执行的指令，生成对应的.o文件(目标文件)。
 
## 链接
链接分为动态链接和静态链接

静态链接:在编译链接期间发挥作用，将目标文件和静态库一起链接形成可执行文件。
动态链接:链接过程推迟到运行时再进行。
动态链接的好处：
- 代码共用：很多程序都可以共同链接动态链接库，但是这些库在内存和磁盘中只有一份
- 易于维护：动态链接发生在运行时，所以动态链接库很容易做更新
- 减少可执行文件体积：相比静态链接，动态链接在编译时不需要搭进去，所以可执行文件的体积要小很多。

动态链接的坏处：
- 动态链接发生在启动或运行时，会增加启动时间。

## dyld（the dynamic link editor） 动态链接器
相关术语说明
+ Executable—iOS 应用程序的主要二进制文件
+ Dylib—Dynamic library，动态库 (其他平台中叫DSO 或者 DLL)
+ Bundle—可以看做是不能链接的Dylib,只能使用dlopen()来加载,就像插件一样
+ Image— 泛指 Executable,Dylib或者Bundle
+ Framework—包含Dylib、图片等资源、头文件(.h)的特定结构的目录文件

动态链接器主要做了下面的事情：
- 加载所用的dylibs
- Fix-ups: Rebase 修正地址偏移，因为 OS X和 iOS 搞了一个叫 ASLR的东西来做地址偏移（随机化）来避免受到攻击。
Image每次分配到的地址偏移量是随机的。
- Fix-ups: binding binding是对指向外部的指针进行校正。校正后的地址信息都是保存在__LINKEDIT中。
每个dylib分配到的地址空间也是随机的，也就是其起始地址会不断的变化，或者说是滑动（slide）。
Rebasing就是在发生变化时，对内部的指针按照新的偏移量进行校正。而binding是对指向外部的指针进行校正。
校正后的地址信息都是保存在__LINKEDIT中。
- 通知ObjC Runtime  初始化：加载所有类。大多数的ObjC设置都通过Rebasing和Binding完成了，比如注册ObjC class 声明，将Category中声明的方法插入到方法列表中。之后，Runtime启动并开始初始化操作
- Initializers：如果是C++，静态对象的initializer开始执行。对于ObjC，+load 方法被调用。

## main()被调用前经历的TimeLine：
![timeLine](file:///Users/mhlee/Desktop/640.png)


静态链接将多个目标文件合并成一个可执行文件。在OSX和iOS中的可执行文件是Mach-O。
Mach-O是OSX和iOS系统可执行文件的格式。
